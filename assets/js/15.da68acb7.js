(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{375:function(e,t,o){"use strict";o.r(t);var s=o(42),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"ecmascript"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ecmascript"}},[e._v("#")]),e._v(" ECMAScript")]),e._v(" "),o("p",[o("img",{attrs:{src:"/img/article/javascript/es/es-logo.jpg",alt:""}})]),e._v(" "),o("h2",{attrs:{id:"es-module"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#es-module"}},[e._v("#")]),e._v(" ES module")]),e._v(" "),o("p",[o("strong",[e._v("加载规则")])]),e._v(" "),o("p",[e._v("浏览器加载ES6模块需要在"),o("code",[e._v("script")]),e._v("标签上加"),o("code",[e._v("type=module")]),e._v("属性。")]),e._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[e._v("\n"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("script type"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"module"')]),e._v(" src"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"./foo.js"')]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("script"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n\n")])])]),o("p",[e._v("浏览器对于带有"),o("code",[e._v("type=module")]),e._v("的"),o("code",[e._v("script")]),e._v("标签，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了defer属性。async属性也可以打开，执行机制是只要该模块加载完成，就执行该模块。")]),e._v(" "),o("p",[o("strong",[e._v("ES6模块运行时加载")])]),e._v(" "),o("p",[o("code",[e._v("import()")]),e._v("接受一个参数，即加载的模块所在位置并返回一个"),o("code",[e._v("Promise")]),e._v("对象，有了这个函数我们就可以做更多的操作，比如按需加载、动态加载、条件加载：")]),e._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[e._v("\n"),o("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" pathName "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token string"}},[e._v("'main'")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" flag "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n\n"),o("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("flag"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),o("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),o("span",{pre:!0,attrs:{class:"token template-string"}},[o("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[e._v("`")]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v("./section-modules/")]),o("span",{pre:!0,attrs:{class:"token interpolation"}},[o("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[e._v("${")]),e._v("pathName"),o("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[e._v("}")])]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v(".js")]),o("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[e._v("`")])]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),o("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("module")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    console"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("module"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("catch")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),o("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("err")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    console"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("err"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),o("p",[o("strong",[e._v("ES6模块与CommonJS模块的差异")])]),e._v(" "),o("ul",[o("li",[e._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。")]),e._v(" "),o("li",[e._v("CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")]),e._v(" "),o("li",[e._v("CommonJS 是同步加载，ES6 模块是异步加载。")])]),e._v(" "),o("p",[e._v("nodejs想要处理es6模块必须把文件后缀改成"),o("code",[e._v("mjs")]),e._v("，或者在"),o("code",[e._v("package.json")]),e._v("里面配置"),o("code",[e._v("type:module")]),e._v(":")]),e._v(" "),o("div",{staticClass:"language-json extra-class"},[o("pre",{pre:!0,attrs:{class:"language-json"}},[o("code",[e._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// package.json")]),e._v("\n\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),o("span",{pre:!0,attrs:{class:"token property"}},[e._v('"type"')]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"module"')]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),o("p",[e._v("需要注意的是一旦你配置了这个字段，那么该配置文件目录中的所有js文件将被解释使用es6模块。如果这时候还想用commonjs则把文件后缀改成cjs。")]),e._v(" "),o("p",[e._v("还有一种做法是在"),o("code",[e._v("package.json")]),e._v("文件的"),o("code",[e._v("exports")]),e._v("字段，指明两种格式模块各自的加载入口。")]),e._v(" "),o("div",{staticClass:"language-json extra-class"},[o("pre",{pre:!0,attrs:{class:"language-json"}},[o("code",[e._v("\n"),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// package.json")]),e._v("\n\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),o("span",{pre:!0,attrs:{class:"token property"}},[e._v('"exports"')]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),o("span",{pre:!0,attrs:{class:"token property"}},[e._v('"require"')]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"main.js"')]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),o("span",{pre:!0,attrs:{class:"token property"}},[e._v('"import"')]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"index.js"')]),e._v("\n    "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),o("p",[o("strong",[e._v("异步加载js文件")])]),e._v(" "),o("p",[e._v("因为浏览器渲染机制，渲染引擎加载到js脚本文件就会停下来等待执行完成后继续渲染，这样就会造成如果你的js文件执行过慢或者出现异常的时候，会造成页面卡死给用户带来非常不好的体验，所以浏览器允许异步加载js脚本，只需要在"),o("code",[e._v("script")]),e._v("标签上加"),o("code",[e._v("defer")]),e._v("或者"),o("code",[e._v("async")]),e._v("属性即代表开启异步加载。")]),e._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[e._v("\n"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("script src"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"path/to/myModule.js"')]),e._v(" defer"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("script"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("script src"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"path/to/myModule.js"')]),e._v(" async"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("script"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n\n")])])]),o("p",[e._v("这个时候又来问题了，那既然这两个属性都可以异步加载js脚本，它们又有什么区别呢？让我们带着问号继续往下看。")]),e._v(" "),o("p",[o("code",[e._v("defer")]),e._v("要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；"),o("code",[e._v("async")]),e._v("一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。")]),e._v(" "),o("h2",{attrs:{id:"proxy"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),o("p",[o("strong",[e._v("什么是Proxy？")])]),e._v(" "),o("p",[e._v("Proxy是es6新增的对象代理，可以拦截对象默认操作，一般是用来做对象的数据保护和修改过滤，接受参数有两个：")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("target")]),e._v(": 目标对象")]),e._v(" "),o("li",[o("code",[e._v("handler")]),e._v(": 处理器，代理对象的默认行为")])]),e._v(" "),o("p",[o("a",{attrs:{href:"https://blog.csdn.net/wuyujin1997/article/details/89137999",target:"_blank",rel:"noopener noreferrer"}},[e._v("handler参数详解参考"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("如果链接访问不了我这里也做了记录。")]),e._v(" "),o("p",[o("code",[e._v("handler")]),e._v("参数详情:")]),e._v(" "),o("ul",[o("li",[o("p",[o("code",[e._v("getPrototypeOf(target)")]),e._v(" 当读取被代理对象target的原型"),o("code",[e._v("prototype")]),e._v("时会触发该操作")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("setPrototypeOf(target, prototype)")]),e._v(" 给"),o("code",[e._v("target")]),e._v("设置"),o("code",[e._v("prototype")]),e._v("时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("isExtensible(target)")]),e._v(" 判断"),o("code",[e._v("target")]),e._v("是否可扩展时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("preventExtensions(target)")]),e._v(" 设置"),o("code",[e._v("target")]),e._v("不可扩展时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("getOwnPropertyDescriptor(target, prop)")]),e._v(" 获取"),o("code",[e._v("target[prop]")]),e._v("的属性描述时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("defineProperty(target, property, descriptor)")]),e._v(" 定义"),o("code",[e._v("target")]),e._v("的某个属性prop的属性描述"),o("code",[e._v("descriptor")]),e._v("时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("has(target, prop)")]),e._v(" 当判断"),o("code",[e._v("target")]),e._v("是否拥有属性"),o("code",[e._v("prop")]),e._v("时，触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("get(target, property, receiver)")]),e._v(" 读取"),o("code",[e._v("target")]),e._v("的属性"),o("code",[e._v("property")]),e._v("时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("set(target, property, value, receiver)")]),e._v(" 设置"),o("code",[e._v("target")]),e._v("的属性"),o("code",[e._v("property")]),e._v("为值"),o("code",[e._v("value")]),e._v("时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("get")]),e._v("中的"),o("code",[e._v("receiver")]),e._v("为"),o("code",[e._v("Proxy")]),e._v("或继承"),o("code",[e._v("Proxy")]),e._v("的对象")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("set")]),e._v("中的"),o("code",[e._v("receiver")]),e._v("是最初被调用的对象(通常是"),o("code",[e._v("Proxy")]),e._v("本身)")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("deleteProperty(target, property)")]),e._v(" 删除"),o("code",[e._v("target")]),e._v("的属性"),o("code",[e._v("property")]),e._v("时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("ownKeys(target)")]),e._v(" 获取"),o("code",[e._v("targeet")]),e._v("的所有属性"),o("code",[e._v("keys")]),e._v("时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("apply(target, thisArg, argumentsList)")]),e._v(" 当目标"),o("code",[e._v("target")]),e._v("为函数，且被调用时触发")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("construct(target, argumentsList, newTarget)")]),e._v(" 给"),o("code",[e._v("target")]),e._v("为构造函数的代理对象构造实例时触发")])])]),e._v(" "),o("p",[e._v("API详情：")]),e._v(" "),o("ul",[o("li",[o("p",[o("code",[e._v("handler.getPrototypeOf(target)")]),e._v(" 返回一个对象或"),o("code",[e._v("null")]),e._v("(不能返回其他类型的原始值)\nJS中，以下5种操作会触发JS引擎读取一个对象的原型("),o("code",[e._v("getPrototypeOf(target)")]),e._v("代理方法的运行)。\n"),o("code",[e._v("Object.getPrototypeOf(object)")]),e._v(" 返回对象"),o("code",[e._v("object")]),e._v("的原型"),o("code",[e._v("prototype")]),e._v("。\n"),o("code",[e._v("Reflect.getPrototypeOf(target)")]),e._v(" "),o("code",[e._v("__proto__")]),e._v("对象的该属性是一个访问器属性(一个"),o("code",[e._v("getter")]),e._v("函数和一个"),o("code",[e._v("setter")]),e._v("函数)。\n"),o("code",[e._v("obj1.isPrototypeOf(obj2)")]),e._v(" 测试对象"),o("code",[e._v("obj1")]),e._v("是否在对象"),o("code",[e._v("obj2")]),e._v("的原型链上。\n"),o("code",[e._v("object instanceof constructor")]),e._v(" 检测构造函数"),o("code",[e._v("constructor的prototype")]),e._v("属性是否出现在对象"),o("code",[e._v("object")]),e._v("的原型链中的任何位置")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.setPrototype(target, prototype)")]),e._v(" 返回"),o("code",[e._v("Boolean")]),e._v("值，表示是否修改了原型\n本方法可以拦截的操作有：\n"),o("code",[e._v("Object.setPrototypeOf(object, prototype)")]),e._v(" "),o("code",[e._v("Reflect.setPrototypeOf(target, prototype)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.isExtensible(target)")]),e._v(" 返回一个"),o("code",[e._v("Boolean")]),e._v("值(或一个可转换为"),o("code",[e._v("Boolean")]),e._v("值的值)\n会拦截以下操作：\n"),o("code",[e._v("Object.isExtensible(object)")]),e._v(" "),o("code",[e._v("Reflect.isExtensible(target)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.preventExtensions(target)")]),e._v(" 返回一个"),o("code",[e._v("Boolean")]),e._v("值\n拦截的操作：\n"),o("code",[e._v("Object.preventExtensions(object)")]),e._v(" "),o("code",[e._v("Reflect.preventExtensions(target)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.getOwnPropertyDescriptor(target, prop)")]),e._v(" 返回一个"),o("code",[e._v("object")]),e._v("或"),o("code",[e._v("undefined")]),e._v("\n拦截的操作：\n"),o("code",[e._v("Object.getOwnPropertyDescriptor(object, prop)")]),e._v(" "),o("code",[e._v("Reflect.getOwnPropertyDescriptor(target, prop)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.defineProperty(target, property, descriptor")]),e._v(" 返回一个"),o("code",[e._v("Boolean")]),e._v("值，表示操作成功/失败\n拦截的操作：\n"),o("code",[e._v("Object.defineProperty(object, property, descriptor)")]),e._v(" "),o("code",[e._v("Reflect.defineProperty(target, property, descriptor)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.has(target, prop)")]),e._v(" 返回一个"),o("code",[e._v("Boolean")]),e._v("值\n"),o("code",[e._v("handler.has(target, prop)")]),e._v("可以看做是in操作的trap。"),o("code",[e._v("()")]),e._v("\n属性查询: "),o("code",[e._v("foo in proxy")]),e._v("\n继承属性查询: "),o("code",[e._v("foo in Object.create(proxy)")]),e._v(" "),o("code",[e._v("with")]),e._v("检查: "),o("code",[e._v("with(ptoxy) {(foo);}")]),e._v(" "),o("code",[e._v("Reflect.has(target, prop)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.get(target, property, receiver)")]),e._v(" "),o("code",[e._v("get")]),e._v("可以返回任何类型的值\n拦截的操作：\n读属性: "),o("code",[e._v("proxy[foo]或proxy.foo")]),e._v("\n访问原型链上的属性: "),o("code",[e._v("Object.create(proxy)[foo]")]),e._v(" "),o("code",[e._v("Reflect.get(target, property, ?receiver)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.set(target, property, value, receiver)")]),e._v(" 返回"),o("code",[e._v("Boolean")]),e._v("值，表示写操作是否成功\n拦截的操作：\n写属性: "),o("code",[e._v("proxy[foo] = xxx")]),e._v("或"),o("code",[e._v("proxy.foo = xxx")]),e._v("\n指定继承者的属性: "),o("code",[e._v("Object.create(proxy)[foo] = xxx")]),e._v(" "),o("code",[e._v("Reflect.set(target, property, value, ?receiver)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.deleteProperty(target, property)")]),e._v(" 返回"),o("code",[e._v("Boolean")]),e._v("值，表示删除是否成功\n拦截的操作：\n删除属性: "),o("code",[e._v("delete proxy[foo]或delete proxy.foo")]),e._v(" "),o("code",[e._v("Reflect.deleteProperty(target, property)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.ownKeys(target)")]),e._v(" 返回一个可枚举对象\n拦截的操作：\n"),o("code",[e._v("Object.getOwnPropertyNames(object)")]),e._v(" 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。\n"),o("code",[e._v("Object.getOenPropertySymbols(object)")]),e._v(" 返回一个给定对象自身的所有 "),o("code",[e._v("Symbol")]),e._v(" 属性的数组。\n"),o("code",[e._v("Object.keys(object)")]),e._v(" 返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 "),o("code",[e._v("for…in")]),e._v(" 循环遍历该对象时返回的顺序一致 。\n"),o("code",[e._v("Reflect.ownKeys(target)")]),e._v(" 返回一个由目标对象自身的属性键组成的数组")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.apply(target, thisArg, argumentsList)")]),e._v(" 可以返回任何类型的值\n拦截的操作：\n"),o("code",[e._v("proxy(...args)")]),e._v(" "),o("code",[e._v("Function.prototype.apply()")]),e._v("和"),o("code",[e._v("Function.prototype.call()")]),e._v("。(即"),o("code",[e._v("foo.apply()")]),e._v("和"),o("code",[e._v("foo.call()")]),e._v(")\n"),o("code",[e._v("Reflect.apply(target, thisArg, argumentsList)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("handler.construct(target, argumentsList, newTarge)")]),e._v(" 返回一个对象\n拦截的操作：\n"),o("code",[e._v("new proxy(...args)")]),e._v(" "),o("code",[e._v("Reflect.construct(target, argumentsList, newTarget)")])])])]),e._v(" "),o("h2",{attrs:{id:"reflect"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#reflect"}},[e._v("#")]),e._v(" Reflect")]),e._v(" "),o("p",[e._v("既然提到了代理就不得不说一下同样为es6新增的API反射。")]),e._v(" "),o("p",[o("strong",[e._v("什么是Reflect？")])]),e._v(" "),o("p",[o("code",[e._v("Object")]),e._v("能做的事我们的"),o("code",[e._v("Reflect")]),e._v("都可以做并且实现的更简单易读，并且以后的新方法只会在"),o("code",[e._v("Reflect")]),e._v("上面部署，而Proxy上面的所有方法"),o("code",[e._v("Reflect")]),e._v("都有对应的实现，实在是一对不可拆散的好基友。可以理解它的作用就是在你拦截了读写操作之后再让它去做该做的事。")]),e._v(" "),o("p",[o("strong",[e._v("为什么要用Reflect")])]),e._v(" "),o("ol",[o("li",[e._v("更加有用的返回值")]),e._v(" "),o("li",[e._v("函数式编程")]),e._v(" "),o("li",[e._v("和"),o("code",[e._v("Proxy")]),e._v("相呼应")]),e._v(" "),o("li",[e._v("从"),o("code",[e._v("Reflect")]),e._v("上可以拿到语言内部的方法")])]),e._v(" "),o("p",[e._v("这块整理一下"),o("code",[e._v("Reflect")]),e._v("的"),o("code",[e._v("API")])]),e._v(" "),o("ul",[o("li",[o("p",[o("code",[e._v("Reflect.get(target, name, receiver)")]),e._v(" 方法查找并返回"),o("code",[e._v("target")]),e._v("对象的"),o("code",[e._v("name")]),e._v("属性，如果\n没有该属性，则返回"),o("code",[e._v("undefined")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.set(target, name, value, receiver)")]),e._v(" "),o("code",[e._v("Reflect.set")]),e._v("方法设置"),o("code",[e._v("target")]),e._v("对象的"),o("code",[e._v("name")]),e._v("属性等于"),o("code",[e._v("value")]),e._v("值")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.has(obj, name)")]),e._v(" "),o("code",[e._v("Reflect.has")]),e._v("方法对应"),o("code",[e._v("in")]),e._v("运算符。")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.construct(target,args)")]),e._v(" "),o("code",[e._v("Reflect.construct")]),e._v("方法等同于"),o("code",[e._v("new target(…args)")]),e._v("，这提供了一种不使用"),o("code",[e._v("new")]),e._v("，来调用构造函数的方法")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.getPrototypeOf(obj)")]),e._v(" "),o("code",[e._v("Reflect.getPrototypeOf")]),e._v("方法用于读取对象的"),o("code",[e._v("_proto_")]),e._v("属性，对应"),o("code",[e._v("Object.getPrototypeOf(obj)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.setPrototypeOf(obj, newProto)")]),e._v(" "),o("code",[e._v("Reflect.setPrototypeOf")]),e._v("方法用于设置对象的"),o("code",[e._v("_proto_")]),e._v("属性，返回第一个参数对象，对应"),o("code",[e._v("Object.setPrototypeOf(obj, newProto)")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.apply(func, thisArg, args)")]),e._v(" "),o("code",[e._v("Reflect.apply")]),e._v("方法等同于"),o("code",[e._v("Function.prototype.apply.call(func, thisArg, args)")]),e._v("，用于绑定"),o("code",[e._v("this")]),e._v("对象后执行给定函数")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.defineProperty(target, propertyKey, attributes)")]),e._v(" "),o("code",[e._v("Reflect.defineProperty")]),e._v("方法基本等同于"),o("code",[e._v("Object.defineProperty")]),e._v("，用来为对象定义属性")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.getOwnPropertyDescriptor(target, propertyKey)")]),e._v(" "),o("code",[e._v("Reflect.getOwnPropertyDescriptor")]),e._v("基本等同于"),o("code",[e._v("Object.getOwnPropertyDescriptor")]),e._v("，用于得到指定属性的描述对象")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.isExtensible (target)")]),e._v(" "),o("code",[e._v("Reflect.isExtensible")]),e._v("方法对应"),o("code",[e._v("Object.isExtensible")]),e._v("，返回一个布尔值，表示当前对象是否可扩展")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.preventExtensions(target)")]),e._v(" "),o("code",[e._v("Reflect.preventExtensions")]),e._v("对应"),o("code",[e._v("Object.preventExtensions")]),e._v("方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Reflect.ownKeys (target)")]),e._v(" "),o("code",[e._v("Reflect.ownKeys")]),e._v("方法用于返回对象的所有属性，基本等同于"),o("code",[e._v("Object")]),e._v("."),o("code",[e._v("getOwnPropertyNames")]),e._v("与"),o("code",[e._v("Object.getOwnPropertySymbols")]),e._v("之和，也就是说对象中使用"),o("code",[e._v("Symbol")]),e._v("作为"),o("code",[e._v("key")]),e._v("的一样可以返回")])])]),e._v(" "),o("h2",{attrs:{id:"暂时性死区"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#暂时性死区"}},[e._v("#")]),e._v(" 暂时性死区")]),e._v(" "),o("p",[e._v("es6给我们带来了声明变量的新关键字"),o("code",[e._v("let")]),e._v("和"),o("code",[e._v("const")])]),e._v(" "),o("p",[e._v("我们都知道var是有变量提升的，但是"),o("code",[e._v("let")]),e._v("有没有，还是很迷的，我认为是存在提升的，不过是由于暂时性死区的限制你不能在变量初始化之前使用；而"),o("code",[e._v("let")]),e._v("有块作用域的概念也就是说在花括号内"),o("code",[e._v("let")]),e._v("是能形成局部作用域的，而在let所处的作用域内（不论是全局还是局部），你在变量初始化之前是无法访问该变量的，这也就是我们所说的暂时性死区。")]),e._v(" "),o("p",[e._v("一句话：所谓暂时死区，就是不能在初始化之前使用变量。")]),e._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    console"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Cannot access 'a' before initialization")]),e._v("\n    "),o("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" a "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v("\n    console"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 10")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),o("p",[e._v("在上述例子中，第一次"),o("code",[e._v("log")]),e._v("就存在于初始化阶段和声明阶段的间隙中，在这个时候a还没有被赋值，存在死区内所以会报错说不能在初始化阶段之前访问;这个时候你需要知道一下js变量的创建过程，分为“创建、初始化和赋值”，在js编译的时候遇到作用域内声明变量的关键字会在执行前向栈中申请内存空间。")]),e._v(" "),o("div",{staticClass:"language-js extra-class"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),o("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" a"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    console"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// undefined")]),e._v("\n    a "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v("\n    console"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("a"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 10")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),o("p",[o("strong",[e._v("区别")])]),e._v(" "),o("p",[e._v("其实就是let在初始化前加了限制不让访问，而var没有。本身var关键字规则就比较松懈，变量在初始化前访问也是不合理的，所以es6增加的let和const是弥补了这个缺陷。")]),e._v(" "),o("Copy")],1)}),[],!1,null,null,null);t.default=r.exports}}]);